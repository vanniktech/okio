{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Okio","text":"<p>Okio is a library that complements <code>java.io</code> and <code>java.nio</code> to make it much easier to access, store, and process your data. It started as a component of OkHttp, the capable HTTP client included in Android. It\u2019s well-exercised and ready to solve new problems.</p>"},{"location":"#bytestrings-and-buffers","title":"ByteStrings and Buffers","text":"<p>Okio is built around two types that pack a lot of capability into a straightforward API:</p> <ul> <li> <p>ByteString is an immutable sequence of bytes. For character data, <code>String</code>    is fundamental. <code>ByteString</code> is String\u2019s long-lost brother, making it easy to    treat binary data as a value. This class is ergonomic: it knows how to encode    and decode itself as hex, base64, and UTF-8.</p> </li> <li> <p>Buffer is a mutable sequence of bytes. Like <code>ArrayList</code>, you don\u2019t need    to size your buffer in advance. You read and write buffers as a queue: write    data to the end and read it from the front. There\u2019s no obligation to manage    positions, limits, or capacities.</p> </li> </ul> <p>Internally, <code>ByteString</code> and <code>Buffer</code> do some clever things to save CPU and memory. If you encode a UTF-8 string as a <code>ByteString</code>, it caches a reference to that string so that if you decode it later, there\u2019s no work to do.</p> <p><code>Buffer</code> is implemented as a linked list of segments. When you move data from one buffer to another, it reassigns ownership of the segments rather than copying the data across. This approach is particularly helpful for multithreaded programs: a thread that talks to the network can exchange data with a worker thread without any copying or ceremony.</p>"},{"location":"#sources-and-sinks","title":"Sources and Sinks","text":"<p>An elegant part of the <code>java.io</code> design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called <code>Source</code> and <code>Sink</code> that work like <code>InputStream</code> and <code>OutputStream</code>, but with some key differences:</p> <ul> <li> <p>Timeouts. The streams provide access to the timeouts of the underlying    I/O mechanism. Unlike the <code>java.io</code> socket streams, both <code>read()</code> and    <code>write()</code> calls honor timeouts.</p> </li> <li> <p>Easy to implement. <code>Source</code> declares three methods: <code>read()</code>, <code>close()</code>,    and <code>timeout()</code>. There are no hazards like <code>available()</code> or single-byte reads    that cause correctness and performance surprises.</p> </li> <li> <p>Easy to use. Although implementations of <code>Source</code> and <code>Sink</code> have only    three methods to write, callers are given a rich API with the    <code>BufferedSource</code> and <code>BufferedSink</code> interfaces. These interfaces give you    everything you need in one place.</p> </li> <li> <p>No artificial distinction between byte streams and char streams. It\u2019s all    data. Read and write it as bytes, UTF-8 strings, big-endian 32-bit integers,    little-endian shorts; whatever you want. No more <code>InputStreamReader</code>!</p> </li> <li> <p>Easy to test. The <code>Buffer</code> class implements both <code>BufferedSource</code> and    <code>BufferedSink</code> so your test code is simple and clear.</p> </li> </ul> <p>Sources and sinks interoperate with <code>InputStream</code> and <code>OutputStream</code>. You can view any <code>Source</code> as an <code>InputStream</code>, and you can view any <code>InputStream</code> as a <code>Source</code>. Similarly for <code>Sink</code> and <code>OutputStream</code>.</p>"},{"location":"#presentations","title":"Presentations","text":"<p>A Few \u201cOk\u201d Libraries (slides): An introduction to Okio and three libraries written with it.</p> <p>Decoding the Secrets of Binary Data (slides): How data encoding works and how Okio does it.</p> <p>Ok Multiplatform! (slides): How we changed Okio\u2019s implementation language from Java to Kotlin.</p> <p>Nerding Out On Okio: The story of the Okio APIs, their design and tradeoffs, as well  as implementation notes with animated marbles diagrams.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Okio 2.x supports Android 4.0.3+ (API level 15+) and Java 7+.</p> <p>Okio 3.x supports Android 4.0.3+ (API level 15+) and Java 8+.</p> <p>Okio depends on the Kotlin standard library. It is a small library with strong backward-compatibility.</p>"},{"location":"#releases","title":"Releases","text":"<p>Our change log has release history.</p> <pre><code>implementation(\"com.squareup.okio:okio:3.9.0\")\n</code></pre> Snapshot builds are also available <pre><code>repositories {\n    maven(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n}\n\ndependencies {\n   implementation(\"com.squareup.okio:okio:3.9.0\")\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2013 Square, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#version-390","title":"Version 3.9.0","text":"<p>2024-03-12</p> <ul> <li>New: <code>FileSystem.SYSTEM</code> can be used in source sets that target both Kotlin/Native and    Kotlin/JVM. Previously, we had this symbol in each source set but it wasn\u2019t available to    common source sets.</li> <li>New: <code>COpaquePointer.readByteString(...)</code> creates a ByteString from a memory address.</li> <li>New: Support <code>InflaterSource</code>, <code>DeflaterSink</code>, <code>GzipSink</code>, and <code>GzipSource</code> in Kotlin/Native.</li> <li>New: Support openZip() on Kotlin/Native. One known bug in this implementation is that    <code>FileMetadata.lastModifiedAtMillis()</code> is interpreted as UTC and not the host machine\u2019s time zone.</li> <li>New: Prefer NTFS timestamps in ZIP file systems\u2019 metadata. This avoids the time zone problems    of ZIP\u2019s built-in DOS timestamps, and the 2038 time bombs of ZIP\u2019s extended timestamps.</li> <li>Fix: Don\u2019t leak file handles to opened JAR files open in <code>FileSystem.RESOURCES</code>.</li> <li>Fix: Don\u2019t throw a <code>NullPointerException</code> if <code>Closeable.use { ... }</code> returns null.</li> </ul>"},{"location":"changelog/#version-380","title":"Version 3.8.0","text":"<p>2024-02-09</p> <ul> <li>New: <code>TypedOptions</code> works like <code>Options</code>, but it returns a <code>T</code> rather than an index.</li> <li>Fix: Don\u2019t leave sinks open when there\u2019s a race in <code>Pipe.fold()</code>.</li> </ul>"},{"location":"changelog/#version-370","title":"Version 3.7.0","text":"<p>2023-12-16</p> <ul> <li>New: <code>Timeout.cancel()</code> prevents a timeout from firing.</li> <li>Breaking: Drop the <code>watchosX86</code> Kotlin/Native target. From the Kotlin blog,    \u2018This is an obsolete simulator for Intel Macs. Use the watchosX64 target instead.\u2019</li> <li>New: Add the <code>watchosDeviceArm64</code> Kotlin/Native target.</li> <li>New: <code>Timeout</code> APIs that accept <code>kotlin.time.Duration</code>.</li> <li>Upgrade: Kotlin 1.9.21.</li> </ul>"},{"location":"changelog/#version-360","title":"Version 3.6.0","text":"<p>2023-10-01</p> <ul> <li>Fix: Don\u2019t leak file handles when using <code>metadata</code> functions on <code>ZipFileSystem</code>. We had a bug    where we were closing the <code>.zip</code> file, but not a stream inside of it. We would have prevented    this bug if only we\u2019d used <code>FakeFileSystem.checkNoOpenFiles()</code> in our tests!</li> <li>Fix: Don\u2019t build an index of a class loader\u2019s resources in <code>ResourceFileSystem.read()</code>. This    operation doesn\u2019t need this index, and building it is potentially expensive.</li> <li>New: Experimentally support Linux on ARM64 for Kotlin/Native targets (<code>linuxArm64</code>). Note that    we haven\u2019t yet added CI test coverage for this platform.</li> <li>Upgrade: Kotlin 1.9.10.</li> </ul>"},{"location":"changelog/#version-1176","title":"Version 1.17.6","text":"<p>2023-10-01</p> <ul> <li>Fix: Don\u2019t crash decoding GZIP files when the optional extra data (<code>XLEN</code>) is 32 KiB or larger.</li> </ul>"},{"location":"changelog/#version-350","title":"Version 3.5.0","text":"<p>2023-08-02</p> <ul> <li>New: Support the WebAssembly (WASM) platform. Okio\u2019s support for WASM is experimental, but    improving, just like Kotlin\u2019s own support for WASM.</li> <li>New: Adapt WebAssembly System Interface (WASI) API\u2019s as an Okio FileSystem using    <code>WasiFileSystem</code>. This is in the new <code>okio-wasifilesystem</code> module. It requires the preview1    WASI API. We\u2019ll make backwards-incompatible upgrades to new WASI API versions as they become    available.</li> <li>Fix: Return relative paths in the NIO adapter FileSystem when required. <code>FileSystem.list()</code>    had always returned absolute paths, even when the target directory was supplied as a relative    path.</li> <li>Fix: Don\u2019t crash when reading into an empty array using <code>FileHandle</code> on Kotlin/Native.</li> <li>Upgrade: Kotlin 1.9.0.</li> </ul>"},{"location":"changelog/#version-340","title":"Version 3.4.0","text":"<p>2023-07-07</p> <ul> <li>New: Adapt a Java NIO FileSystem (<code>java.nio.file.FileSystem</code>) as an Okio FileSystem using    <code>fileSystem.asOkioFileSystem()</code>.</li> <li>New: Adapt Android\u2019s <code>AssetManager</code> as an Okio FileSystem using <code>AssetFileSystem</code>. This is in the    new <code>okio-assetfilesystem</code> module. Android applications should prefer this over    <code>FileSystem.RESOURCES</code> as it\u2019s faster to load.</li> <li>Fix: Don\u2019t crash decoding GZIP files when the optional extra data (<code>XLEN</code>) is 32 KiB or larger.</li> <li>Fix: Resolve symlinks in <code>FakeFileSystem.canonicalize()</code>.</li> <li>Fix: Report the correct <code>createdAtMillis</code> in <code>NodeJsFileSystem</code> file metadata. We were    incorrectly using <code>ctimeMs</code>, where <code>c</code> means changed, not created.</li> <li>Fix: <code>UnsafeCursor</code> is now <code>Closeable</code>.</li> </ul>"},{"location":"changelog/#version-330","title":"Version 3.3.0","text":"<p>2023-01-07</p> <ul> <li>Fix: Don\u2019t leak resources when <code>use {}</code> is used with a non-local return. We introduced this    performance and stability bug by not considering that non-local returns execute neither the    <code>return</code> nor <code>catch</code> control flows.</li> <li>Fix: Use a sealed interface for <code>BufferedSink</code> and <code>BufferedSource</code>. These were never intended    for end-users to implement, and we\u2019re happy that Kotlin now allows us to express that in our API.</li> <li>New: Change internal locks from <code>synchronized</code> to <code>ReentrantLock</code> and <code>Condition</code>. We expect this    to improve help when using Okio with Java virtual threads (Project Loom).</li> <li>Upgrade: Kotlin 1.8.0.</li> </ul>"},{"location":"changelog/#version-320","title":"Version 3.2.0","text":"<p>2022-06-26</p> <ul> <li>Fix: Configure the multiplatform artifact (<code>com.squareup.okio:okio:3.x.x</code>) to depend on the    JVM artifact (<code>com.squareup.okio:okio-jvm:3.x.x</code>) for Maven builds. This should work-around an    issue where Maven doesn\u2019t interpret Gradle metadata.</li> <li>Fix: Change <code>CipherSource</code> and <code>CipherSink</code> to recover if the cipher doesn\u2019t support streaming.    This should work around a crash with AES/GCM ciphers on Android.</li> <li>New: Enable compatibility with non-hierarchical projects.</li> </ul>"},{"location":"changelog/#version-310","title":"Version 3.1.0","text":"<p>2022-04-19</p> <ul> <li>Upgrade: Kotlin 1.6.20.</li> <li>New: Support Hierarchical project structure. If you\u2019re using Okio in a    multiplatform project please upgrade your project to Kotlin 1.6.20 (or newer) to take advantage    of this. With hierarchical projects it\u2019s easier to use properties like <code>FileSystem.SYSTEM</code> that    are available on most Okio platforms but not all of them.</li> <li>New: <code>ForwardingSource</code> is now available on all platforms.</li> <li>New: The <code>watchosX64</code> platform is now supported.</li> <li>Fix: Don\u2019t crash in `NSData.toByteString()\u2019 when the input is empty.</li> <li>Fix: Support empty ZIP files in <code>FileSystem.openZip()</code>.</li> <li>Fix: Throw in <code>canonicalize()</code> of ZIP file systems if the path doesn\u2019t exist.</li> <li>Fix: Don\u2019t require ZIP files start with a local file header.</li> <li>New: <code>okio.ProtocolException</code> is a new exception type for multiplatform users. (It is aliased to    <code>java.net.ProtocolException</code> on JVM platforms).</li> </ul>"},{"location":"changelog/#version-300","title":"Version 3.0.0","text":"<p>2021-10-28</p> <p>This is the first stable release of Okio 3.x. This release is strongly backwards-compatible with Okio 2.x, and the new major version signifies new capabilities more than it does backwards incompatibility.</p> <p>Most users should be able to upgrade from 2.x by just changing the version. If you\u2019re using Okio in a Kotlin Multiplatform project, you\u2019ll need to drop the <code>-multiplatform</code> suffix in your Gradle dependencies.</p> <ul> <li>New: Remove <code>@ExperimentalFileSystem</code>. This annotation is no longer necessary as the file system    is no longer experimental!</li> <li>New: Path no longer aggressively normalizes <code>..</code> segments. Use <code>Path.normalize()</code> to apply these    based on the content of the path, or <code>FileSystem.canonicalize()</code> to do it honoring any symlinks    on a particular file system.</li> <li>New: Publish a bill of materials (BOM) for Okio. Depend on this from Gradle or Maven to    keep all of your Okio artifacts on the same version, even if they\u2019re declared via transitive    dependencies. You can even omit versions when declaring other Okio dependencies.</li> </ul> <pre><code>dependencies {\n   api(platform(\"com.squareup.okio:okio-bom:3.0.0\"))\n   api(\"com.squareup.okio:okio\")                // No version!\n   api(\"com.squareup.okio:okio-fakefilesystem\") // No version!\n}\n</code></pre> <ul> <li>New: <code>FileSystem.delete()</code> silently succeeds when deleting a file that doesn\u2019t exist. Use    the new <code>mustExist</code> parameter to trigger an exception instead.</li> <li>New: <code>FileSystem.createDirectories()</code> silently succeeds when creating a directory that already    exists. Use the new <code>mustCreate</code> parameter to trigger an exception instead.</li> <li>New: <code>FileSystem</code> offers Java-language overloads where appropriate. Previously functions that    had default parameters were potentially awkward to invoke from Java.</li> <li>New: <code>Timeout.intersectWith()</code> returns a value instead of <code>Unit</code>. This is a binary-incompatible    change. We expect that this public API is very rarely used outside of Okio itself.</li> <li>Fix: Change <code>BufferedSource.readDecimalLong()</code> to fail if the input value is just <code>-</code>. Previously    Okio incorrectly returned <code>0</code> for this.</li> </ul>"},{"location":"changelog/#version-300-alpha11","title":"Version 3.0.0-alpha.11","text":"<p>2021-10-23</p> <ul> <li>Upgrade: Kotlin 1.5.31.</li> <li>Upgrade: kotlinx-datetime 0.3.0. (This is a dependency of <code>okio-fakefilesystem</code>    only.)</li> <li>New: Support creating and accessing symlinks. We were reluctant to include symlinks in our API    (to keep it small!) but decided that supporting them was essential to properly implement    recursive traversal.</li> <li>New: <code>FileMetadata.extras</code> can track metadata for custom <code>FileSystem</code> implementations.</li> <li>New: Support Apple Silicon Kotlin/Native targets (<code>macosArm64</code>, <code>iosSimulatorArm64</code>,    <code>tvosSimulatorArm64</code>, and <code>watchosSimulatorArm64</code>).</li> <li>New: <code>FileSystem.listRecursively()</code> returns a <code>Sequence</code> that includes all of a directory\u2019s    children, and all of their children recursively. The implementation does a lazy, depth-first    traversal.</li> <li>New: <code>Path.relativeTo()</code> computes how to get from one path to another.</li> <li>New: <code>Path.root</code> and <code>Path.segments</code>. These APIs decompose a path into its component parts.</li> <li>New: <code>FileSystem.listOrNull()</code> returns a directory\u2019s children, or null if the path doesn\u2019t    reference a readable directory.</li> <li>New: Option to fail if the file being updated doesn\u2019t already exist: <code>mustExist</code>. Use this to    avoid creating a new file when your intention is to update an existing file.</li> <li>New: Option to fail if a file being created already exists: <code>mustCreate</code>. Use this to avoid    updating an existing file when your intention is to create a new file.</li> <li>Fix: Restore support for Kotlin/JS on browser platforms. We were relying on NodeJS-only features    to fetch the local directory separator (<code>/</code> or <code>\\</code>) and temporary directory.</li> <li>Fix: Don\u2019t ignore the caller\u2019s specified write offset running Okio on Kotlin/Native on Linux.    (<code>FileHandle.write()</code> was broken and always appended to the end of the file.)</li> </ul>"},{"location":"changelog/#version-300-alpha10","title":"Version 3.0.0-alpha.10","text":"<p>2021-09-09</p> <p>This release drops the <code>-multiplatform</code> suffix on Kotlin Multiplatform artifacts. All artifacts now share the same name (like <code>com.squareup.okio:okio:3.0.0-alpha.10</code>) for both Kotlin/JVM and Kotlin Multiplatform.</p> <ul> <li>Fix: Don\u2019t crash in <code>ResourceFileSystem</code> when classpath <code>.jar</code> files have special characters in    their paths.</li> </ul>"},{"location":"changelog/#version-300-alpha9","title":"Version 3.0.0-alpha.9","text":"<p>2021-08-01</p> <ul> <li>New: <code>ByteString.copyInto()</code> saves an allocation when extracting data from a <code>ByteString</code>.</li> <li>Fix: Create <code>FileHandle.protectedSize()</code> to match other abstract functions.</li> <li>Fix: Open files in binary mode on Windows. Without this, files that contain <code>0x1a</code> will be    truncated prematurely.</li> </ul>"},{"location":"changelog/#version-300-alpha8","title":"Version 3.0.0-alpha.8","text":"<p>2021-07-13</p> <ul> <li>Fix: Don\u2019t crash on duplicate entries in a .zip file.</li> <li>Fix: Change <code>FileSystem.RESOURCES</code> to initialize itself lazily.</li> </ul>"},{"location":"changelog/#version-300-alpha7","title":"Version 3.0.0-alpha.7","text":"<p>2021-07-12</p> <ul> <li>Fix: Change <code>ResourceFileSystem</code> to load roots eagerly. We had a bug where <code>list()</code> on the root    returned an empty list even if resources were present.</li> <li>New: <code>FileHandle.reposition()</code> can seek on a source or sink returned by that <code>FileHandle</code>.</li> <li>New: Move the system resources instance to <code>FileSystem.RESOURCES</code>.</li> <li>Upgrade: Kotlin 1.5.20.</li> </ul>"},{"location":"changelog/#version-300-alpha6","title":"Version 3.0.0-alpha.6","text":"<p>2021-06-01</p> <ul> <li>New: <code>FileHandle</code> supports random access reads, writes, and resizes on files. Create an instance    with <code>FileSystem.openReadOnly()</code> or <code>FileSystem.openReadWrite()</code>.</li> <li>New: Remove <code>Cursor</code> which is obsoleted by <code>FileHandle</code>. (<code>UnsafeCursor</code> is still around!)</li> <li>New: Add support for the new intermediate representation (IR) artifacts in Kotlin/JS. We still    support the legacy artifact format.</li> <li>New: Support tvOS (tvosArm64, tvosX64) in multiplatform.</li> <li>New: Change <code>ResourceFileSystem</code> to omit <code>.class</code> files when indexing <code>.zip</code> files. We expect    this to lower the memory footprint of <code>ResourceFileSystem</code>.</li> <li>Fix: Don\u2019t crash on background thread access in Kotlin/Native. We had to apply <code>@SharedImmutable</code>    and run our test suite on a background thread.</li> </ul>"},{"location":"changelog/#version-300-alpha5","title":"Version 3.0.0-alpha.5","text":"<p>2021-04-27</p> <ul> <li>New: Promote the <code>ZipFileSystem</code> and <code>ResourceFileSystem</code> to the main Okio module. These are    currently JVM-only. The <code>okio-zipfilesystem</code> module is no longer published.</li> </ul>"},{"location":"changelog/#version-300-alpha4","title":"Version 3.0.0-alpha.4","text":"<p>2021-04-14</p> <ul> <li>Fix: Rename internal classes to avoid name collisions. We were seeing problems due to having    multiple files named <code>-Platform.kt</code>.</li> </ul>"},{"location":"changelog/#version-300-alpha3","title":"Version 3.0.0-alpha.3","text":"<p>2021-04-06</p> <ul> <li>New: Move <code>NodeJsFileSystem</code> into its own module. Having it built-in prevented Okio from working    in a browser where there\u2019s no synchronous file system API. This is in the <code>okio-nodefilesystem</code>    artifact.</li> </ul>"},{"location":"changelog/#version-300-alpha2","title":"Version 3.0.0-alpha.2","text":"<p>2021-03-24</p> <ul> <li>New: Require Java 8+ for Okio 3.x.</li> <li>New: <code>Cursor</code> supports random access reads on a <code>Source</code>.</li> <li>New: <code>FileSystem.openZip(path)</code> returns a file system backed by a <code>.zip</code> file. This is in the    <code>okio-zipfilesystem</code> artifact.</li> </ul>"},{"location":"changelog/#version-300-alpha1","title":"Version 3.0.0-alpha.1","text":"<p>2021-01-07</p> <ul> <li>New: Experimental file system API. The <code>Path</code>, <code>FileMetadata</code>, <code>FileSystem</code> and   <code>ForwardingFileSystem</code> types are subject to API changes in a future release.</li> <li>New: Experimental <code>okio-fakefilesystem</code> artifact.</li> </ul>"},{"location":"changelog/#version-2100","title":"Version 2.10.0","text":"<p>2021-01-07</p> <ul> <li>New: Support Windows (mingwX64) in multiplatform.</li> <li>New: Support watchOS (watchosArm32, watchosArm64, watchosX86) in multiplatform.</li> <li>New: Support <code>HashingSource</code>, <code>HashingSink</code>, buffer hash functions, and <code>UnsafeCursor</code> on non-JVM   platforms. Previously these were all JVM-only.</li> <li>New: Implement <code>Closeable</code> on <code>Sink</code> and <code>Source</code> on non-JVM platforms. Okio now includes a   multiplatform <code>okio.Closeable</code> interface and corresponding <code>use {}</code> extension. Closing resources   when you\u2019re done with them shouldn\u2019t be JVM-only!</li> <li>New: <code>Sink.hashingSink</code> and <code>Source.hashingSource</code> functions that accept   <code>java.security.MessageDigest</code> and <code>javax.crypto.Mac</code> instances. Use these when your hash function   isn\u2019t built-in.</li> <li>Fix: Don\u2019t crash with a <code>ShortBufferException</code> in <code>CipherSink</code> and <code>CipherSource</code> on Android.   (Android may throw a <code>ShortBufferException</code> even if the buffer is not too short. We now   avoid this problem!)</li> <li>Upgrade: Kotlin 1.4.20.</li> </ul>"},{"location":"changelog/#version-290","title":"Version 2.9.0","text":"<p>2020-10-04</p> <ul> <li>Fix: Don\u2019t corrupt the <code>Buffer</code> when writing a slice of a segmented <code>ByteString</code>. We had a severe    bug where <code>ByteString</code> instances created with <code>snapshot()</code> and <code>readByteString()</code> incorrectly    adjusted the buffer\u2019s size by their full length, not the length of the slice. This would have    caused buffer reads to crash! We do not believe data was silently corrupted.</li> <li>New: <code>CipherSink</code> and <code>CipherSource</code>. Use these with <code>javax.crypto.Cipher</code> to encrypt and decrypt    streams of data. This is a low-level encryption API; most applications should use higher-level    APIs like TLS when available.</li> <li>New: Promote hash functions <code>md5</code>, <code>sha1()</code>, <code>sha512()</code>, and <code>sha256()</code> to common Kotlin. These    are currently only available on <code>ByteString</code>, multiplatform support for <code>HashingSource</code>,    <code>HashingSink</code>, and <code>Buffer</code> should come in a follow-up release. We wrote and optimized our own    implementations of these hash functions in Kotlin. On JVM and Android platforms Okio still uses    the platform\u2019s built-in hash functions.</li> <li>New: Support OSGi metadata.</li> <li>Upgrade: Kotlin 1.4.10.</li> </ul>"},{"location":"changelog/#version-280","title":"Version 2.8.0","text":"<p>2020-08-17</p> <ul> <li>New: Upgrade to Kotlin 1.4.0.</li> </ul>"},{"location":"changelog/#version-270","title":"Version 2.7.0","text":"<p>2020-07-07</p> <ul> <li> <p>New: <code>Pipe.cancel()</code> causes in-progress and future reads and writes on the pipe to immediately    fail with an <code>IOException</code>. The streams may still be canceled normally.</p> </li> <li> <p>New: Enlarge Okio\u2019s internal segment pool from a fixed 64 KiB total to 64 KiB per processor. For    example, on an Intel i9 8-core/16-thread machine the segment pool now uses up to 1 MiB of memory.</p> </li> <li> <p>New: Migrate from <code>synchronized</code> to lock-free when accessing the segment pool. Combined with the    change above we saw throughput increase 3x on a synthetic benchmark designed to create    contention.</p> </li> </ul>"},{"location":"changelog/#version-260","title":"Version 2.6.0","text":"<p>2020-04-22</p> <ul> <li>New: <code>InflaterSource.readOrInflate()</code> is like <code>InflaterSource.read()</code>, except it will return 0 if    consuming deflated bytes from the underlying stream did not produce new inflated bytes.</li> </ul>"},{"location":"changelog/#version-250","title":"Version 2.5.0","text":"<p>2020-03-20</p> <ul> <li>New: Upgrade to Kotlin 1.3.70.</li> </ul>"},{"location":"changelog/#version-243","title":"Version 2.4.3","text":"<p>2019-12-20</p> <ul> <li>New: Upgrade to Kotlin 1.3.61.</li> </ul>"},{"location":"changelog/#version-242","title":"Version 2.4.2","text":"<p>2019-12-11</p> <ul> <li>Fix: Don\u2019t crash when an <code>InputStream</code> source is exhausted exactly at a buffer segment boundary.    We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result    in a crash when subsequent reads encountered an unexpected empty segment.</li> </ul>"},{"location":"changelog/#version-1175","title":"Version 1.17.5","text":"<p>2019-12-11</p> <ul> <li>Fix: Don\u2019t crash when an <code>InputStream</code> source is exhausted exactly at a buffer segment boundary.    We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result    in a crash when subsequent reads encountered an unexpected empty segment.</li> </ul>"},{"location":"changelog/#version-241","title":"Version 2.4.1","text":"<p>2019-10-04</p> <ul> <li>Fix: Don\u2019t cache hash code and UTF-8 string in <code>ByteString</code> on Kotlin/Native which prevented freezing.</li> </ul>"},{"location":"changelog/#version-240","title":"Version 2.4.0","text":"<p>2019-08-26</p> <ul> <li>New: Upgrade to Kotlin 1.3.50.</li> </ul>"},{"location":"changelog/#version-230","title":"Version 2.3.0","text":"<p>2019-07-29</p> <p>This release changes our build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both native and JavaScript platforms are unstable preview releases and subject to backwards-incompatible changes in forthcoming releases.</p> <p>To try Okio in a multiplatform project use this Maven coordinate:</p> <pre><code>api('com.squareup.okio:okio-multiplatform:2.3.0')\n</code></pre> <p>You\u2019ll also need to enable Gradle metadata in your project\u2019s settings. The artifact name for JVM projects has not changed.</p> <ul> <li>New: Upgrade to Kotlin 1.3.40.</li> <li>Fix: Use Gradle <code>api</code> instead of <code>implementation</code> for the kotlin-stdlib dependency.</li> <li>Fix: Don\u2019t block unless strictly necessary in <code>BufferedSource.peek()</code>.</li> </ul>"},{"location":"changelog/#version-1174","title":"Version 1.17.4","text":"<p>2019-04-29</p> <ul> <li>Fix: Don\u2019t block unless strictly necessary in <code>BufferedSource.peek()</code>.</li> </ul>"},{"location":"changelog/#version-222","title":"Version 2.2.2","text":"<p>2019-01-28</p> <ul> <li>Fix: Make <code>Pipe.fold()</code> close the underlying sink when necessary.</li> </ul>"},{"location":"changelog/#version-1173","title":"Version 1.17.3","text":"<p>2019-01-28</p> <ul> <li>Fix: Make <code>Pipe.fold()</code> close the underlying sink when necessary.</li> </ul>"},{"location":"changelog/#version-1172","title":"Version 1.17.2","text":"<p>2019-01-17</p> <ul> <li>Fix: Make <code>Pipe.fold()</code> flush the underlying sink.</li> </ul>"},{"location":"changelog/#version-221","title":"Version 2.2.1","text":"<p>2019-01-17</p> <ul> <li>Fix: Make <code>Pipe.fold()</code> flush the underlying sink.</li> </ul>"},{"location":"changelog/#version-220","title":"Version 2.2.0","text":"<p>2019-01-16</p> <ul> <li> <p>New: <code>Throttler</code> limits sources and sinks to a maximum desired throughput. Multiple sources and    sinks can be attached to the same throttler and their combined throughput will not exceed the    desired throughput. Multiple throttlers can also be used on the same source or sink and they will    all be honored.</p> </li> <li> <p>New: <code>Pipe.fold()</code> replaces the actively-readable <code>Source</code> with a passively-writable <code>Sink</code>.    This can be used to forward one sink to a target that is initially undetermined.</p> </li> <li> <p>New: Optimize performance of ByteStrings created with <code>Buffer.snapshot()</code>.</p> </li> </ul>"},{"location":"changelog/#version-1171","title":"Version 1.17.1","text":"<p>2019-01-16</p> <ul> <li>Fix: Make the newly-backported <code>Pipe.fold()</code> public.</li> </ul>"},{"location":"changelog/#version-1170","title":"Version 1.17.0","text":"<p>2019-01-16</p> <ul> <li>New: Backport <code>Pipe.fold()</code> to Okio 1.x.</li> </ul>"},{"location":"changelog/#version-1160","title":"Version 1.16.0","text":"<p>2018-10-08</p> <ul> <li>New: Backport <code>BufferedSource.peek()</code> and <code>BufferedSource.getBuffer()</code> to Okio 1.x.</li> <li>Fix: Enforce timeouts when closing <code>AsyncTimeout</code> sources.</li> </ul>"},{"location":"changelog/#version-210","title":"Version 2.1.0","text":"<p>2018-09-22</p> <ul> <li> <p>New: <code>BufferedSource.peek()</code> returns another <code>BufferedSource</code> that reads ahead on the current    source. Use this to process the same data multiple times.</p> </li> <li> <p>New: Deprecate <code>BufferedSource.buffer()</code>, replacing it with either <code>BufferedSource.getBuffer()</code>    (in Java) or <code>BufferedSource.buffer</code> (in Kotlin). We have done likewise for <code>BufferedSink</code>.    When we introduced the new extension method <code>Source.buffer()</code> in Okio 2.0 we inadvertently    collided with an existing method. This fixes that.</p> </li> <li> <p>New: Improve performance of <code>Buffer.writeUtf8()</code>. This comes alongside initial implementation of    UTF-8 encoding and decoding in JavaScript which uses XOR masks for great performance.</p> </li> </ul>"},{"location":"changelog/#version-200","title":"Version 2.0.0","text":"<p>2018-08-27</p> <p>This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x.</p> <p>We\u2019ve also added APIs to ease migration for Kotlin users. They use Kotlin\u2019s <code>@Deprecated</code> annotation to help you change call sites from the 1.x style to the 2.x style.</p>"},{"location":"changelog/#version-200-rc1","title":"Version 2.0.0-RC1","text":"<p>2018-07-26</p> <p>Okio 2 is a major release that upgrades the library\u2019s implementation language from Java to Kotlin.</p> <p>Okio 2.x is binary-compatible with Okio 1.x and does not change any behavior. Classes and .jar files compiled against 1.x can be used with 2.x without recompiling.</p> <p>Okio 2.x is .java source compatible with Okio 1.x in all but one corner case. In Okio 1.x <code>Buffer</code> would throw an unchecked <code>IllegalStateException</code> when attempting to read more bytes than available. Okio 2.x now throws a checked <code>EOFException</code> in this case. This is now consistent with the behavior of its <code>BufferedSource</code> interface. Java callers that don\u2019t already catch <code>IOException</code> will now need to.</p> <p>Okio 2.x is .kt source-incompatible with Okio 1.x. This release adopts Kotlin idioms where they are available.</p> Java Kotlin Idiom Buffer.getByte() operator fun Buffer.get() operator function Buffer.size() val Buffer.size val ByteString.decodeBase64(String) fun String.decodeBase64() extension function ByteString.decodeHex(String) fun String.decodeHex() extension function ByteString.encodeString(String, Charset) fun String.encode(Charset) extension function ByteString.encodeUtf8(String) fun String.encodeUtf8() extension function ByteString.getByte() operator fun ByteString.get() operator function ByteString.of(ByteBuffer) fun ByteBuffer.toByteString() extension function ByteString.of(byte[], int, int) fun ByteArray.toByteString() extension function ByteString.read(InputStream, int) fun InputStream.readByteString(Int) extension function ByteString.size() val ByteString.size val DeflaterSink(Sink) fun Sink.deflater() extension function ForwardingSink.delegate() val ForwardingSink.delegate val ForwardingSource.delegate() val ForwardingSource.delegate val GzipSink(Sink, Deflater) fun Sink.gzip() extension function GzipSink.deflater() val GzipSink.deflater val GzipSource(Source) fun Source.gzip() extension function HashingSink.hash() val HashingSink.hash val HashingSource.hash() val HashingSource.hash val InflaterSink(Source) fun Source.inflater() extension function Okio.appendingSink(File) fun File.appendingSink() extension function Okio.blackhole() fun blackholeSink() top level function Okio.buffer(Sink) fun Sink.buffer() extension function Okio.buffer(Source) fun Source.buffer() extension function Okio.sink(File) fun File.sink() extension function Okio.sink(OutputStream) fun OutputStream.sink() extension function Okio.sink(Path) fun Path.sink() extension function Okio.sink(Socket) fun Socket.sink() extension function Okio.source(File) fun File.source() extension function Okio.source(InputStream) fun InputStream.source() extension function Okio.source(Path) fun Path.source() extension function Okio.source(Socket) fun Socket.source() extension function Pipe.sink() val Pipe.sink val Pipe.source() val Pipe.source val Utf8.size(String) fun String.utf8Size() extension function <p>Okio 2.x has similar performance to Okio 1.x. We benchmarked both versions to find potential performance regressions. We found one regression and fixed it: we were using <code>==</code> instead of <code>===</code>.</p> <p>Other changes in this release:</p> <ul> <li> <p>New: Add a dependency on kotlin-stdlib. Okio\u2019s transitive dependencies grow from none in 1.x to    three in 2.x. These are kotlin-stdlib (939 KiB), kotlin-stdlib-common (104 KiB), and JetBrains\u2019    annotations (17 KiB).</p> </li> <li> <p>New: Change Okio to build with Gradle instead of Maven.</p> </li> </ul>"},{"location":"changelog/#version-1150","title":"Version 1.15.0","text":"<p>2018-07-18</p> <ul> <li>New: Trie-based <code>Buffer.select()</code>. This improves performance when selecting    among large lists of options.</li> <li>Fix: Retain interrupted state when throwing <code>InterruptedIOException</code>.</li> </ul>"},{"location":"changelog/#version-1140","title":"Version 1.14.0","text":"<p>2018-02-11</p> <ul> <li>New: <code>Buffer.UnsafeCursor</code> provides direct access to Okio internals. This API    is like Okio\u2019s version of Java reflection: it\u2019s a very powerful API that can    be used for great things and dangerous things alike. The documentation is    extensive and anyone using it should review it carefully before proceeding!</li> <li>New: Change <code>BufferedSource</code> to implement <code>java.nio.ReadableByteChannel</code> and    <code>BufferedSink</code> to implement <code>java.nio.WritableByteChannel</code>. Now it\u2019s a little    easier to interop between Okio and NIO.</li> <li>New: Automatic module name of <code>okio</code> for use with the Java Platform Module    System.</li> <li>New: Optimize <code>Buffer.getByte()</code> to search backwards when doing so will be    more efficient.</li> <li>Fix: Honor the requested byte count in <code>InflaterSource</code>. Previously this    class could return more bytes than requested.</li> <li>Fix: Improve a performance bug in <code>AsyncTimeout.sink().write()</code>.</li> </ul>"},{"location":"changelog/#version-1130","title":"Version 1.13.0","text":"<p>2017-05-12</p> <ul> <li> <p>Okio now uses <code>@Nullable</code> to annotate all possibly-null values. We\u2019ve    added a compile-time dependency on the JSR 305 annotations. This is a    provided dependency and does not need to be included in    your build configuration, <code>.jar</code> file, or <code>.apk</code>. We use    <code>@ParametersAreNonnullByDefault</code> and all parameters and return types are    never null unless explicitly annotated <code>@Nullable</code>.</p> </li> <li> <p>Warning: this release is source-incompatible for Kotlin users.    Nullability was previously ambiguous and lenient but now the compiler will    enforce strict null checks.</p> </li> </ul>"},{"location":"changelog/#version-1120","title":"Version 1.12.0","text":"<p>2017-04-11</p> <ul> <li>Fix: Change Pipe\u2019s sink.flush() to not block. Previously closing a pipe\u2019s    sink would block until the source had been exhausted. In practice this    blocked the caller for no benefit.</li> <li>Fix: Change <code>writeUtf8CodePoint()</code> to emit <code>?</code> for partial surrogates.    The previous behavior was inconsistent: given a malformed string with a    partial surrogate, <code>writeUtf8()</code> emitted <code>?</code> but <code>writeUtf8CodePoint()</code> threw    an <code>IllegalArgumentException</code>. Most applications will never encounter partial    surrogates, but for those that do this behavior was unexpected.</li> <li>New: Allow length of <code>readUtf8LineStrict()</code> to be limited.</li> <li>New: <code>Utf8.size()</code> method to get the number of bytes required to encode a    string as UTF-8. This may be useful for length-prefixed encodings.</li> <li>New: SHA-512 hash and HMAC APIs.</li> </ul>"},{"location":"changelog/#version-1110","title":"Version 1.11.0","text":"<p>2016-10-11</p> <ul> <li>Fix: The four-argument overload of <code>Buffer.writeString()</code> had a major bug    where it didn\u2019t respect offsets if the specified charset was UTF-8. This    was because our short-circuit optimization omitted necessary offset    parameters.</li> <li>New: HMAC support in <code>HashingSource</code>, <code>HashingSink</code>, <code>ByteString</code>, and    <code>Buffer</code>. This makes it easy to create a keyed-hash message authentication    code (HMAC) wherever your data is. Unlike the other hashes, HMAC uses a    <code>ByteString</code> secret key for authentication.</li> <li>New: <code>ByteString.of(ByteBuffer)</code> makes it easier to mix NIO with Okio.</li> </ul>"},{"location":"changelog/#version-1100","title":"Version 1.10.0","text":"<p>2016-08-28</p> <ul> <li>Fix: Support reading files larger than 2 GiB with <code>GzipSource</code>. Previously    attempting to decompress such files would fail due to an overflow when    validating the total length.</li> <li>Fix: Exit the watchdog thread after being idle for 60 seconds. This should    make it possible for class unloaders to fully unload Okio.</li> <li>New: <code>Okio.blackhole()</code> returns a sink where all bytes written are discarded.    This is Okio\u2019s equivalent of <code>/dev/null</code>.</li> <li>New: Encode a string with any charset using <code>ByteString.encodeString()</code> and    decode strings in any charset using <code>ByteString.string()</code>. Most applications    should prefer <code>ByteString.encodeUtf8()</code> and <code>ByteString.utf8()</code> unless it\u2019s    necessary to support a legacy charset.</li> <li>New: <code>GzipSink.deflater()</code> makes it possible to configure the compression    level.</li> </ul>"},{"location":"changelog/#version-190","title":"Version 1.9.0","text":"<p>2016-07-01</p> <ul> <li>New: <code>Pipe</code> makes it easy to connect a producer thread to a consumer thread.    Reads block until data is available to read. Writes block if the pipe\u2019s is    full. Both sources and sinks support timeouts.</li> <li>New: <code>BufferedSource.rangeEquals()</code> makes it easy to compare a range in a    stream to an expected value. This does the right thing: it blocks to load    the data required return a definitive result. But it won\u2019t block    unnecessarily.</li> <li>New: <code>Timeout.waitUntilNotified()</code> makes it possible to use nice timeout    abstractions on Java\u2019s built-in wait/notify primitives.</li> <li>Fix: Don\u2019t return incorrect results when <code>HashingSource</code> does large reads.    There was a bug where it wasn\u2019t traversing through the segments of the buffer    being hashed. This means that <code>HashingSource</code> was returning incorrect answers    for any writes that spanned multiple segment boundaries.</li> </ul>"},{"location":"changelog/#version-180","title":"Version 1.8.0","text":"<p>2016-05-02</p> <ul> <li>New: <code>BufferedSource.select(Options)</code> API for reading one of a set of    expected values.</li> <li>New: Make <code>ByteString.toString()</code> and <code>Buffer.toString()</code> friendlier.    These methods return text if the byte string is valid UTF-8.</li> <li>New: APIs to match byte strings: <code>indexOf()</code>, <code>startsWith()</code>, and    <code>endsWith()</code>.</li> </ul>"},{"location":"changelog/#version-170","title":"Version 1.7.0","text":"<p>2016-04-10</p> <ul> <li>New: Change the segment size to 8 KiB. This has been reported to dramatically    improve performance in some applications.</li> <li>New: <code>md5()</code>, <code>sha1()</code>, and <code>sha256()</code> methods on <code>Buffer</code>. Also add a    <code>sha1()</code> method on <code>ByteString</code> for symmetry.</li> <li>New: <code>HashingSource</code> and <code>HashingSink</code>. These classes are Okio\u2019s equivalent    to the JDK\u2019s <code>DigestInputStream</code> and <code>DigestOutputStream</code>. They offer    convenient <code>md5()</code>, <code>sha1()</code>, and <code>sha256()</code> factory methods to avoid an    impossible <code>NoSuchAlgorithmException</code>.</li> <li>New: <code>ByteString.asByteBuffer()</code>.</li> <li>Fix: Limit snapshot byte strings to requested size.</li> <li>Fix: Change write timeouts to have a maximum write size. Previously large    writes could easly suffer timeouts because the entire write was subject to a    single timeout.</li> <li>Fix: Recover from EBADF failures, which could be triggered by asynchronously    closing a stream on older versions of Android.</li> <li>Fix: Don\u2019t share segments if doing so only saves a small copy. This should    improve performance for all applications.</li> <li>Fix: Optimize <code>BufferedSource.indexOfElement()</code> and <code>indexOf(ByteString)</code>.    Previously this method had a bug that caused it to be very slow on large    buffers.</li> </ul>"},{"location":"changelog/#version-160","title":"Version 1.6.0","text":"<p>2015-08-25</p> <ul> <li>New: <code>BufferedSource.indexOf(ByteString)</code> searches a source for the next    occurrence of a byte string.</li> <li>Fix: Recover from unexpected <code>AssertionError</code> thrown on Android 4.2.2 and    earlier when asynchronously closing a socket.</li> </ul>"},{"location":"changelog/#version-150","title":"Version 1.5.0","text":"<p>2015-06-19</p> <ul> <li>Sockets streams now throw <code>SocketTimeoutException</code>. This builds on new    extension point in <code>AsyncTimeout</code> to customize the exception when a timeout    occurs.</li> <li>New: <code>ByteString</code> now implements <code>Comparable</code>. The comparison sorts bytes as    unsigned: {@code ff} sorts after {@code 00}.</li> </ul>"},{"location":"changelog/#version-140","title":"Version 1.4.0","text":"<p>2015-05-16</p> <ul> <li>Timeout exception changed. Previously <code>Timeout.throwIfReached()</code> would    throw <code>InterruptedIOException</code> on thread interruption, and <code>IOException</code> if    the deadline was reached. Now it throws <code>InterruptedIOException</code> in both    cases.</li> <li>Fix: throw <code>EOFException</code> when attempting to read digits from an empty    source. Previously this would crash with an unchecked exception.</li> <li>New: APIs to read and write UTF-8 code points without allocating strings.</li> <li>New: <code>BufferedSink</code> can now write substrings directly, potentially saving an    allocation for some callers.</li> <li>New: <code>ForwardingTimeout</code> class.</li> </ul>"},{"location":"changelog/#version-130","title":"Version 1.3.0","text":"<p>2015-03-16</p> <ul> <li>New: Read and write signed decimal and unsigned hexadecimal values in    <code>BufferedSource</code> and <code>BufferedSink</code>. Unlike the alternatives, these methods    don\u2019t do any memory allocations!</li> <li>New: Segment sharing. This improves the runtime of operations like    <code>Buffer.clone()</code> and <code>Buffer.copyTo()</code> by sharing underlying segments between    buffers.</li> <li>New: <code>Buffer.snapshot()</code> returns an immutable snapshot of a buffer as a    <code>ByteString</code>. This builds on segment sharing so that snapshots are shallow,    immutable copies.</li> <li>New: <code>ByteString.rangeEquals()</code>.</li> <li>New: <code>ByteString.md5()</code> and <code>ByteString.sha256()</code>.</li> <li>New: <code>ByteString.base64Url()</code> returns URL-safe Base64. The existing    decoding method has been extended to support URL-safe Base64 input.</li> <li>New: <code>ByteString.substring()</code> returns a prefix, infix, or suffix.</li> <li>New: <code>Sink</code> now implements <code>java.io.Flushable</code>.</li> <li>Fix: <code>Buffer.write(Source, long)</code> now always writes fully. The previous    behavior would return as soon as any data had been written; this was    inconsistent with all other write() methods in the API.</li> <li>Fix: don\u2019t leak empty segments in DeflaterSink and InflaterSource. (This was    unlikely to cause problems in practice.)</li> </ul>"},{"location":"changelog/#version-120","title":"Version 1.2.0","text":"<p>2014-12-30</p> <ul> <li>Fix: <code>Okio.buffer()</code> always buffers for better predictability.</li> <li>Fix: Provide context when <code>readUtf8LineStrict()</code> throws.</li> <li>Fix: Buffers do not call through the <code>Source</code> on zero-byte writes.</li> </ul>"},{"location":"changelog/#version-110","title":"Version 1.1.0","text":"<p>2014-12-11</p> <ul> <li>Do UTF-8 encoding natively for a performance increase, particularly on Android.</li> <li>New APIs: <code>BufferedSink.emit()</code>, <code>BufferedSource.request()</code> and <code>BufferedSink.indexOfElement()</code>.</li> <li>Fixed a performance bug in <code>Buffer.indexOf()</code></li> </ul>"},{"location":"changelog/#version-101","title":"Version 1.0.1","text":"<p>2014-08-08</p> <ul> <li>Added <code>read(byte[])</code>, <code>read(byte[], offset, byteCount)</code>,  and    <code>void readFully(byte[])</code> to <code>BufferedSource</code>.</li> <li>Refined declared checked exceptions on <code>Buffer</code> methods.</li> </ul>"},{"location":"changelog/#version-100","title":"Version 1.0.0","text":"<p>2014-05-23</p> <ul> <li>Bumped release version. No other changes!</li> </ul>"},{"location":"changelog/#version-090","title":"Version 0.9.0","text":"<p>2014-05-03</p> <ul> <li>Use 0 as a sentinel for no timeout.</li> <li>Make AsyncTimeout public.</li> <li>Remove checked exception from Buffer.readByteArray.</li> </ul>"},{"location":"changelog/#version-080","title":"Version 0.8.0","text":"<p>2014-04-24</p> <ul> <li>Eagerly verify preconditions on public APIs.</li> <li>Quick return on Buffer instance equivalence.</li> <li>Add delegate types for Sink and Source.</li> <li>Small changes to the way deadlines are managed.</li> <li>Add append variant of Okio.sink for File.</li> <li>Methods to exhaust BufferedSource to byte[] and ByteString.</li> </ul>"},{"location":"changelog/#version-070","title":"Version 0.7.0","text":"<p>2014-04-18</p> <ul> <li>Don\u2019t use getters in timeout.</li> <li>Use the watchdog to interrupt sockets that have reached deadlines.</li> <li>Add java.io and java.nio file source/sink helpers.</li> </ul>"},{"location":"changelog/#version-061","title":"Version 0.6.1","text":"<p>2014-04-17</p> <ul> <li>Methods to read a buffered source fully in UTF-8 or supplied charset.</li> <li>API to read a byte[] directly.</li> <li>New methods to move all data from a source to a sink.</li> <li>Fix a bug on input stream exhaustion.</li> </ul>"},{"location":"changelog/#version-060","title":"Version 0.6.0","text":"<p>2014-04-15</p> <ul> <li>Make ByteString serializable.</li> <li>New API: <code>ByteString.of(byte[] data, int offset, int byteCount)</code></li> <li>New API: stream-based copy, write, and read helpers.</li> </ul>"},{"location":"changelog/#version-050","title":"Version 0.5.0","text":"<p>2014-04-08</p> <ul> <li>Initial public release.</li> <li>Imported from OkHttp.</li> </ul>"},{"location":"code_of_conduct/","title":"Open Source Code of Conduct","text":"<p>At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone.</p> <p>This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored.</p> <p>Square\u2019s open source community strives to:</p> <ul> <li> <p>Be open: We invite anyone to participate in any aspect of our projects. Our community is    open, and any responsibility can be carried by a contributor who demonstrates the required    capacity and competence.</p> </li> <li> <p>Be considerate: People use our work, and we depend on the work of others. Consider users and    colleagues before taking action. For example, changes to code, infrastructure, policy, and    documentation may negatively impact others.</p> </li> <li> <p>Be respectful: We expect people to work together to resolve conflict, assume good intentions,    and act with empathy. Do not turn disagreements into personal attacks.</p> </li> <li> <p>Be collaborative: Collaboration reduces redundancy and improves the quality of our work. We    strive for transparency within our open source community, and we work closely with upstream    developers and others in the free software community to coordinate our efforts.</p> </li> <li> <p>Be pragmatic: Questions are encouraged and should be asked early in the process to avoid    problems later. Be thoughtful and considerate when seeking out the appropriate forum for your    questions. Those who are asked should be responsive and helpful.</p> </li> <li> <p>Step down considerately: Members of every project come and go. When somebody leaves or    disengages from the project, they should make it known and take the proper steps to ensure that    others can pick up where they left off.</p> </li> </ul> <p>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.</p>"},{"location":"code_of_conduct/#diversity-statement","title":"Diversity Statement","text":"<p>We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal.</p> <p>Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong.</p> <p>Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.</p>"},{"location":"code_of_conduct/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. For more details, please see our Reporting Guidelines below.</p>"},{"location":"code_of_conduct/#thanks","title":"Thanks","text":"<p>Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter, Ubuntu, GDC, and Django communities. We are thankful for their work.</p>"},{"location":"code_of_conduct/#reporting-guide","title":"Reporting Guide","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. All reports will be handled with discretion.</p> <p>In your report please include:</p> <ul> <li>Your contact information.</li> <li>Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional    witnesses, please include them as well.</li> <li>Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly    available record (e.g. a mailing list archive or a public IRC logger), please include a link.</li> <li>Any additional information that may be helpful.</li> </ul> <p>After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond.</p> <p>Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome.</p> <p>If you\u2019ve found a security problem, please follow our bug bounty program.</p> <p>If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it.</p> <p>Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA).</p>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":"<p>Get working code on a personal branch with tests passing before you submit a PR:</p> <pre><code>./gradlew clean check\n</code></pre> <p>Please make every effort to follow existing conventions and style in order to keep the code as readable as possible.</p> <p>Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge.</p>"},{"location":"contributing/#committers-guides","title":"Committer\u2019s Guides","text":"<ul> <li>Releasing</li> </ul>"},{"location":"file_system/","title":"File System","text":"<p>Okio\u2019s file system is designed to be easy, testable, multiplatform, and efficient.</p>"},{"location":"file_system/#easy","title":"Easy","text":"<p>Reading and writing files is concise yet flexible.</p> <pre><code>val path = \"README.md\".toPath()\n\nval readmeContent = FileSystem.SYSTEM.read(path) {\n  readUtf8()\n}\n\nval updatedContent = readmeContent.replace(\"red\", \"blue\")\n\nFileSystem.SYSTEM.write(path) {\n  writeUtf8(updatedContent)\n}\n</code></pre>"},{"location":"file_system/#testable","title":"Testable","text":"<p>It\u2019s easy to swap out the real file system with a fake. This makes tests run faster and more reliably.</p> <pre><code>val fileSystem = FakeFileSystem()\nval userHome = \"/Users/sandy\".toPath()\nval gitConfig = userHome / \".gitconfig\"\n\nfileSystem.createDirectories(userHome)\nval original = \"\"\"\n    |[user]\n    |  email = sandy@example.com\n    |\"\"\".trimMargin()\nfileSystem.write(gitConfig) { writeUtf8(original) }\n\nGitConfigFixer(fileSystem).fix(userHome)\n\nval expected = \"\"\"\n  |[user]\n  |  email = sandy@example.com\n  |[diff]\n  |  renames = true\n  |  indentHeuristic = on\n  \"\"\".trimIndent()\nassertEquals(expected, fileSystem.read(gitConfig) { readUtf8() })\n</code></pre> <p>With <code>ForwardingFileSystem</code> you can easily inject faults to confirm your program is graceful even when the user\u2019s disk fills up.</p>"},{"location":"file_system/#multiplatform","title":"Multiplatform","text":"<p>Okio\u2019s <code>Path</code> class supports Windows-style (like <code>C:\\autoexec.bat</code>) and UNIX-style paths (like <code>/etc/passwd</code>). It supports manipulating Windows paths on UNIX, and UNIX paths on Windows.</p> <p>The system <code>FileSystem</code> abstracts over these platform APIs:</p> <ul> <li>Android API levels &lt;26: java.io.File</li> <li>Java and Android API level 26+: java.nio.file</li> <li>Linux: man pages</li> <li>UNIX: stdio.h</li> <li>Windows: fileapi.h</li> <li>Node.js: file system</li> </ul>"},{"location":"file_system/#efficient","title":"Efficient","text":"<p>Read and write operations integrate with Okio buffers to reduce the number of system calls.</p> <p>It exposes high-level operations like <code>atomicMove()</code> and <code>metadata</code> to get the OS to do all the work when appropriate.</p>"},{"location":"file_system/#known-issues","title":"Known Issues","text":"<p>Okio\u2019s implementation is constrained by the capabilities its underlying APIs. This page is an overview of these limitations.</p>"},{"location":"file_system/#all-platforms","title":"All Platforms","text":"<ul> <li>There are no APIs for file permissions, watches, volume management, memory mapping, or locking.</li> <li>Paths that cannot be represented as UTF-8 strings are unsupported. The underlying APIs that Okio    calls through, including <code>java.io.File</code>, all treat paths as strings.</li> </ul>"},{"location":"file_system/#kotlinjvm","title":"Kotlin/JVM","text":""},{"location":"file_system/#on-android-api-level-less-than-26","title":"On Android, API level less than 26:","text":"<ul> <li>Creating and accessing symlinks is unsupported.</li> </ul>"},{"location":"file_system/#on-windows","title":"On Windows:","text":"<ul> <li><code>FileSystem.atomicMove()</code> fails if the target file already exists.</li> </ul>"},{"location":"file_system/#kotlinnative","title":"Kotlin/Native","text":"<ul> <li>FakeFileSystem does not support concurrent use. We are holding off on this    until the upcoming memory model is released.</li> </ul>"},{"location":"file_system/#on-windows_1","title":"On Windows:","text":"<ul> <li>Creating and accessing symlinks is unsupported.</li> </ul>"},{"location":"file_system/#kotlinjs","title":"Kotlin/JS","text":"<ul> <li>NodeJsFileSystem\u2019s <code>source()</code> and <code>sink()</code> cannot access UNIX pipes.</li> <li>Instead of returning null, <code>NodeJsFileSystem.metadataOrNull()</code> throws <code>IOException</code> if the path    is invalid. (In the Node.js API there\u2019s no mechanism to differentiate between a failure to read    a valid path and a rejection of an invalid path.)</li> </ul>"},{"location":"java_io_recipes/","title":"java.io Recipes","text":"<p>These recipes use Okio with <code>java.io.File</code> instead of Okio\u2019s own <code>Path</code> and <code>FileSystem</code> types.</p>"},{"location":"java_io_recipes/#read-a-text-file-line-by-line-javakotlin","title":"Read a text file line-by-line (Java/Kotlin)","text":"<p>This is similar to the other line-by-line example, but it uses <code>java.io.File</code> instead of <code>okio.Path</code> and <code>okio.FileSystem</code>.</p> JavaKotlin <pre><code>public void readLines(File file) throws IOException {\n  try (Source fileSource = Okio.source(file);\n       BufferedSource bufferedFileSource = Okio.buffer(fileSource)) {\n\n    while (true) {\n      String line = bufferedFileSource.readUtf8Line();\n      if (line == null) break;\n\n      if (line.contains(\"square\")) {\n        System.out.println(line);\n      }\n    }\n\n  }\n}\n</code></pre> <p>Note that static <code>Okio</code> methods become extension functions (<code>Okio.source(file)</code> =&gt; <code>file.source()</code>).</p> <pre><code>@Throws(IOException::class)\nfun readLines(file: File) {\n  file.source().use { fileSource -&gt;\n    fileSource.buffer().use { bufferedFileSource -&gt;\n      while (true) {\n        val line = bufferedFileSource.readUtf8Line() ?: break\n        if (\"square\" in line) {\n          println(line)\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"java_io_recipes/#write-a-text-file-javakotlin","title":"Write a text file (Java/Kotlin)","text":"<p>This is similar to the other write example, but it uses <code>java.io.File</code> instead of <code>okio.Path</code> and <code>okio.FileSystem</code>.</p> JavaKotlin <pre><code>public void writeEnv(File file) throws IOException {\n  try (Sink fileSink = Okio.sink(file);\n       BufferedSink bufferedSink = Okio.buffer(fileSink)) {\n\n    for (Map.Entry&lt;String, String&gt; entry : System.getenv().entrySet()) {\n      bufferedSink.writeUtf8(entry.getKey());\n      bufferedSink.writeUtf8(\"=\");\n      bufferedSink.writeUtf8(entry.getValue());\n      bufferedSink.writeUtf8(\"\\n\");\n    }\n\n  }\n}\n</code></pre> <pre><code>@Throws(IOException::class)\nfun writeEnv(file: File) {\n  file.sink().buffer().use { sink -&gt;\n    for ((key, value) in System.getenv()) {\n      sink.writeUtf8(key)\n      sink.writeUtf8(\"=\")\n      sink.writeUtf8(value)\n      sink.writeUtf8(\"\\n\")\n    }\n  }\n}\n</code></pre>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>Okio is a Kotlin Multiplatform project. We\u2019re still completing our feature coverage.</p>"},{"location":"multiplatform/#compression-deflater-inflater-gzip","title":"Compression (Deflater, Inflater, Gzip)","text":"<p>JVM-only.</p>"},{"location":"multiplatform/#concurrency-pipe-timeouts-throttler","title":"Concurrency (Pipe, Timeouts, Throttler)","text":"<p>JVM-only.</p> <p>Timeout is on all platforms, but only the JVM has a useful implementation.</p>"},{"location":"multiplatform/#core-buffer-bytestring-source-sink","title":"Core (Buffer, ByteString, Source, Sink)","text":"<p>Available on all platforms.</p>"},{"location":"multiplatform/#file-system","title":"File System","text":"<p>Available on all platforms. For JavaScript this requires Node.js.</p>"},{"location":"multiplatform/#hashing","title":"Hashing","text":"<p>Okio includes Kotlin implementations of MD5, SHA-1, SHA-256, and SHA-512. This includes both hash functions and HMAC functions.</p> <p>Okio uses the built-in implementations of these functions on the JVM.</p>"},{"location":"multiplatform/#gradle-configuration","title":"Gradle configuration","text":"<pre><code>// build.gradle.kts\nkotlin {\n    sourceSets {\n        val okioVersion = \"3.XXX\"\n        val commonMain by getting {\n            dependencies {\n                implementation(\"com.squareup.okio:okio:$okioVersion\")\n            }\n        }\n        val jsMain by getting {\n            dependencies {\n                implementation(\"com.squareup.okio:okio-nodefilesystem:$okioVersion\")\n            }\n        }\n        val commonTest by getting {\n            dependencies {\n                implementation(\"com.squareup.okio:okio-fakefilesystem:$okioVersion\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"recipes/","title":"Recipes","text":"<p>We\u2019ve written some recipes that demonstrate how to solve common problems with Okio. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for.</p> <p>These recipes work on all platforms: Java, Android, Kotlin/Native, and Kotlin/JS. See java.io Recipes for samples that integrate Java APIs.</p>"},{"location":"recipes/#read-a-text-file-line-by-line-javakotlin","title":"Read a text file line-by-line (Java/Kotlin)","text":"<p>Use <code>FileSystem.source(Path)</code> to open a source stream to read a file. The returned <code>Source</code> interface is very small and has limited uses. Instead we wrap the source with a buffer. This has two benefits:</p> <ul> <li> <p>It makes the API more powerful. Instead of the basic methods offered by <code>Source</code>,    <code>BufferedSource</code> has dozens of methods to address most common problems concisely.</p> </li> <li> <p>It makes your program run faster. Buffering allows Okio to get more done with fewer I/O    operations.</p> </li> </ul> <p>Each <code>Source</code> that is opened needs to be closed. The code that opens the stream is responsible for making sure it is closed.</p> JavaKotlin <p>Here we use Java\u2019s <code>try</code> blocks to close our sources automatically.</p> <pre><code>public void readLines(Path path) throws IOException {\n  try (Source fileSource = FileSystem.SYSTEM.source(path);\n       BufferedSource bufferedFileSource = Okio.buffer(fileSource)) {\n\n    while (true) {\n      String line = bufferedFileSource.readUtf8Line();\n      if (line == null) break;\n\n      if (line.contains(\"square\")) {\n        System.out.println(line);\n      }\n    }\n\n  }\n}\n</code></pre> <p>This uses <code>use</code> to automatically close the streams. This prevents resource leaks, even if an exception is thrown.</p> <pre><code>fun readLines(path: Path) {\n  FileSystem.SYSTEM.source(path).use { fileSource -&gt;\n    fileSource.buffer().use { bufferedFileSource -&gt;\n      while (true) {\n        val line = bufferedFileSource.readUtf8Line() ?: break\n        if (\"square\" in line) {\n          println(line)\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>The <code>readUtf8Line()</code> API reads all of the data until the next line delimiter \u2013 either <code>\\n</code>, <code>\\r\\n</code>, or the end of the file. It returns that data as a string, omitting the delimiter at the end. When it encounters empty lines the method will return an empty string. If there isn\u2019t any more data to read it will return null.</p> JavaKotlin <p>The above Java program can be written more compactly by inlining the <code>fileSource</code> variable and by using a fancy <code>for</code> loop instead of a <code>while</code>:</p> <pre><code>public void readLines(Path path) throws IOException {\n  try (BufferedSource source = Okio.buffer(FileSystem.SYSTEM.source(path))) {\n    for (String line; (line = source.readUtf8Line()) != null; ) {\n      if (line.contains(\"square\")) {\n        System.out.println(line);\n      }\n    }\n  }\n}\n</code></pre> <p>In Kotlin, we can use <code>FileSystem.read()</code> to buffer the source before our block and close the source afterwards. In the body of the block, <code>this</code> is a <code>BufferedSource</code>.</p> <pre><code>@Throws(IOException::class)\nfun readLines(path: Path) {\n  FileSystem.SYSTEM.read(path) {\n    while (true) {\n      val line = readUtf8Line() ?: break\n      if (\"square\" in line) {\n        println(line)\n      }\n    }\n  }\n}\n</code></pre> <p>The <code>readUtf8Line()</code> method is suitable for parsing most files. For certain use-cases you may also consider <code>readUtf8LineStrict()</code>. It is similar but it requires that each line is terminated by <code>\\n</code> or <code>\\r\\n</code>. If it encounters the end of the file before that it will throw an <code>EOFException</code>. The strict variant also permits a byte limit to defend against malformed input.</p> JavaKotlin <pre><code>public void readLines(Path path) throws IOException {\n  try (BufferedSource source = Okio.buffer(FileSystem.SYSTEM.source(path))) {\n    while (!source.exhausted()) {\n      String line = source.readUtf8LineStrict(1024L);\n      if (line.contains(\"square\")) {\n        System.out.println(line);\n      }\n    }\n  }\n}\n</code></pre> <pre><code>@Throws(IOException::class)\nfun readLines(path: Path) {\n  FileSystem.SYSTEM.read(path) {\n    while (!source.exhausted()) {\n      val line = source.readUtf8LineStrict(1024)\n      if (\"square\" in line) {\n        println(line)\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"recipes/#write-a-text-file-javakotlin","title":"Write a text file (Java/Kotlin)","text":"<p>Above we used a <code>Source</code> and a <code>BufferedSource</code> to read a file. To write, we use a <code>Sink</code> and a <code>BufferedSink</code>. The advantages of buffering are the same: a more capable API and better performance.</p> <pre><code>public void writeEnv(Path path) throws IOException {\n  try (Sink fileSink = FileSystem.SYSTEM.sink(path);\n       BufferedSink bufferedSink = Okio.buffer(fileSink)) {\n\n    for (Map.Entry&lt;String, String&gt; entry : System.getenv().entrySet()) {\n      bufferedSink.writeUtf8(entry.getKey());\n      bufferedSink.writeUtf8(\"=\");\n      bufferedSink.writeUtf8(entry.getValue());\n      bufferedSink.writeUtf8(\"\\n\");\n    }\n\n  }\n}\n</code></pre> <p>There isn\u2019t an API to write a line of input; instead we manually insert our own newline character. Most programs should hardcode <code>\"\\n\"</code> as the newline character. In rare situations you may use <code>System.lineSeparator()</code> instead of <code>\"\\n\"</code>: it returns <code>\"\\r\\n\"</code> on Windows and <code>\"\\n\"</code> everywhere else.</p> JavaKotlin <p>We can write the above program more compactly by inlining the <code>fileSink</code> variable and by taking advantage of method chaining:</p> <pre><code>public void writeEnv(Path path) throws IOException {\n  try (BufferedSink sink = Okio.buffer(FileSystem.SYSTEM.sink(path))) {\n    for (Map.Entry&lt;String, String&gt; entry : System.getenv().entrySet()) {\n      sink.writeUtf8(entry.getKey())\n        .writeUtf8(\"=\")\n        .writeUtf8(entry.getValue())\n        .writeUtf8(\"\\n\");\n    }\n  }\n}\n</code></pre> <p>In Kotlin, we can use <code>FileSystem.write()</code> to buffer the sink before our block and close the sink afterwards. In the body of the block, <code>this</code> is a <code>BufferedSink</code>.</p> <pre><code>@Throws(IOException::class)\nfun writeEnv(path: Path) {\n  FileSystem.SYSTEM.write(path) {\n    for ((key, value) in System.getenv()) {\n      writeUtf8(key)\n      writeUtf8(\"=\")\n      writeUtf8(value)\n      writeUtf8(\"\\n\")\n    }\n  }\n}\n</code></pre> <p>In the above code we make four calls to <code>writeUtf8()</code>. Making four calls is more efficient than the code below because the VM doesn\u2019t have to create and garbage collect a temporary string.</p> <pre><code>sink.writeUtf8(entry.getKey() + \"=\" + entry.getValue() + \"\\n\"); // Slower!\n</code></pre>"},{"location":"recipes/#utf-8-javakotlin","title":"UTF-8 (Java/Kotlin)","text":"<p>In the above APIs you can see that Okio really likes UTF-8. Early computer systems suffered many incompatible character encodings: ISO-8859-1, ShiftJIS, ASCII, EBCDIC, etc. Writing software to support multiple character sets was awful and we didn\u2019t even have emoji! Today we\u2019re lucky that the world has standardized on UTF-8 everywhere, with some rare uses of other charsets in legacy systems.</p> <p>If you need another character set, <code>readString()</code> and <code>writeString()</code> are there for you. These  methods require that you specify a character set. Otherwise you may accidentally create data that  is only readable by the local computer. Most programs should use the UTF-8 methods only.</p> <p>When encoding strings you need to be mindful of the different ways that strings are represented and encoded. When a glyph has an accent or another adornment it may be represented as a single complex  code point (<code>\u00e9</code>) or as a simple code point (<code>e</code>) followed by its modifiers (<code>\u00b4</code>). When the entire  glyph is a single code point that\u2019s called NFC; when it\u2019s multiple it\u2019s NFD.</p> <p>Though we use UTF-8 whenever we read or write strings in I/O, when they are in memory Java Strings use an obsolete character encoding called UTF-16. It is a bad encoding because it uses a 16-bit <code>char</code> for most characters, but some don\u2019t fit. In particular, most emoji use two Java chars. This is problematic because <code>String.length()</code> returns a surprising result: the number of UTF-16 chars and not the natural number of glyphs.</p> Caf\u00e9 \ud83c\udf69 Cafe\u0301 \ud83c\udf69 Form NFC NFD Code Points <code>c\u00a0\u00a0a\u00a0\u00a0f\u00a0\u00a0\u00e9\u00a0\u00a0\u00a0\u00a0\u2423\u00a0\u00a0\u00a0\ud83c\udf69</code> <code>c\u00a0\u00a0a\u00a0\u00a0f\u00a0\u00a0e\u00a0\u00a0\u00b4\u00a0\u00a0\u00a0\u00a0\u2423\u00a0\u00a0\u00a0\ud83c\udf69</code> UTF-8 bytes <code>43 61 66 c3a9 20 f09f8da9</code> <code>43 61 66 65 cc81 20 f09f8da9</code> String.codePointCount 6 7 String.length 7 8 Utf8.size 10 11 <p>For the most part Okio lets you ignore these problems and focus on your data. But when you need them, there are convenient APIs for dealing with low-level UTF-8 strings.</p> <p>Use <code>Utf8.size()</code> to count the number of bytes required to encode a string as UTF-8 without actually encoding it. This is handy in length-prefixed encodings like protocol buffers.</p> <p>Use <code>BufferedSource.readUtf8CodePoint()</code> to read a single variable-length code point, and <code>BufferedSink.writeUtf8CodePoint()</code> to write one.</p> JavaKotlin <pre><code>public void dumpStringData(String s) throws IOException {\n  System.out.println(\"                       \" + s);\n  System.out.println(\"        String.length: \" + s.length());\n  System.out.println(\"String.codePointCount: \" + s.codePointCount(0, s.length()));\n  System.out.println(\"            Utf8.size: \" + Utf8.size(s));\n  System.out.println(\"          UTF-8 bytes: \" + ByteString.encodeUtf8(s).hex());\n  System.out.println();\n}\n</code></pre> <pre><code>fun dumpStringData(s: String) {\n  println(\"                       \" + s)\n  println(\"        String.length: \" + s.length)\n  println(\"String.codePointCount: \" + s.codePointCount(0, s.length))\n  println(\"            Utf8.size: \" + s.utf8Size())\n  println(\"          UTF-8 bytes: \" + s.encodeUtf8().hex())\n  println()\n}\n</code></pre>"},{"location":"recipes/#golden-values-javakotlin","title":"Golden Values (Java/Kotlin)","text":"<p>Okio likes testing. The library itself is heavily tested, and it has features that are often helpful when testing application code. One pattern we\u2019ve found to be quite useful is \u201cgolden value\u201d testing. The goal of such tests is to confirm that data encoded with earlier versions of a program can safely be decoded by the current program.</p> <p>We\u2019ll illustrate this by encoding a value using Java Serialization. Though we must disclaim that Java Serialization is an awful encoding system and most programs should prefer other formats like JSON or protobuf! In any case, here\u2019s a method that takes an object, serializes it, and returns the result as a <code>ByteString</code>:</p> JavaKotlin <pre><code>private ByteString serialize(Object o) throws IOException {\n  Buffer buffer = new Buffer();\n  try (ObjectOutputStream objectOut = new ObjectOutputStream(buffer.outputStream())) {\n    objectOut.writeObject(o);\n  }\n  return buffer.readByteString();\n}\n</code></pre> <pre><code>@Throws(IOException::class)\nprivate fun serialize(o: Any?): ByteString {\n  val buffer = Buffer()\n  ObjectOutputStream(buffer.outputStream()).use { objectOut -&gt;\n    objectOut.writeObject(o)\n  }\n  return buffer.readByteString()\n}\n</code></pre> <p>There\u2019s a lot going on here.</p> <ol> <li> <p>We create a buffer as a holding space for our serialized data. It\u2019s a convenient replacement for    <code>ByteArrayOutputStream</code>.</p> </li> <li> <p>We ask the buffer for its output stream. Writes to a buffer or its output stream always append    data to the end of the buffer.</p> </li> <li> <p>We create an <code>ObjectOutputStream</code> (the encoding API for Java serialization) and write our object.    The try block takes care of closing the stream for us. Note that closing a buffer has no effect.</p> </li> <li> <p>Finally we read a byte string from the buffer. The <code>readByteString()</code> method allows us to specify    how many bytes to read; here we don\u2019t specify a count in order to read the entire thing. Reads    from a buffer always consume data from the front of the buffer.</p> </li> </ol> <p>With our <code>serialize()</code> method handy we are ready to compute and print a golden value.</p> JavaKotlin <pre><code>Point point = new Point(8.0, 15.0);\nByteString pointBytes = serialize(point);\nSystem.out.println(pointBytes.base64());\n</code></pre> <pre><code>val point = Point(8.0, 15.0)\nval pointBytes = serialize(point)\nprintln(pointBytes.base64())\n</code></pre> <p>We print the <code>ByteString</code> as base64 because it\u2019s a compact format that\u2019s suitable for embedding in a test case. The program prints this:</p> <pre><code>rO0ABXNyAB5va2lvLnNhbXBsZXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\n</code></pre> <p>That\u2019s our golden value! We can embed it in our test case using base64 again to convert it back into a <code>ByteString</code>:</p> JavaKotlin <pre><code>ByteString goldenBytes = ByteString.decodeBase64(\"rO0ABXNyAB5va2lvLnNhbXBsZ\"\n    + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\"\n    + \"AAAAAAA\");\n</code></pre> <pre><code>val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" +\n  \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64()\n</code></pre> <p>The next step is to deserialize the <code>ByteString</code> back into our value class. This method reverses the <code>serialize()</code> method above: we append a byte string to a buffer then consume it using an <code>ObjectInputStream</code>:</p> JavaKotlin <pre><code>private Object deserialize(ByteString byteString) throws IOException, ClassNotFoundException {\n  Buffer buffer = new Buffer();\n  buffer.write(byteString);\n  try (ObjectInputStream objectIn = new ObjectInputStream(buffer.inputStream())) {\n    return objectIn.readObject();\n  }\n}\n</code></pre> <pre><code>@Throws(IOException::class, ClassNotFoundException::class)\nprivate fun deserialize(byteString: ByteString): Any? {\n  val buffer = Buffer()\n  buffer.write(byteString)\n  ObjectInputStream(buffer.inputStream()).use { objectIn -&gt;\n    return objectIn.readObject()\n  }\n}\n</code></pre> <p>Now we can test the decoder against the golden value:</p> JavaKotlin <pre><code>ByteString goldenBytes = ByteString.decodeBase64(\"rO0ABXNyAB5va2lvLnNhbXBsZ\"\n    + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\"\n    + \"AAAAAAA\");\nPoint decoded = (Point) deserialize(goldenBytes);\nassertEquals(new Point(8.0, 15.0), decoded);\n</code></pre> <pre><code>val goldenBytes = (\"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" +\n  \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\").decodeBase64()!!\nval decoded = deserialize(goldenBytes) as Point\nassertEquals(point, decoded)\n</code></pre> <p>With this test we can change the serialization of the <code>Point</code> class without breaking compatibility.</p>"},{"location":"recipes/#write-a-binary-file-javakotlin","title":"Write a binary file (Java/Kotlin)","text":"<p>Encoding a binary file is not unlike encoding a text file. Okio uses the same <code>BufferedSink</code> and <code>BufferedSource</code> bytes for both. This is handy for binary formats that include both byte and character data.</p> <p>Writing binary data is more hazardous than text because if you make a mistake it is often quite difficult to diagnose. Avoid such mistakes by being careful around these traps:</p> <ul> <li> <p>The width of each field. This is the number of bytes used. Okio doesn\u2019t include a mechanism    to emit partial bytes. If you need that, you\u2019ll need to do your own bit shifting and masking    before writing.</p> </li> <li> <p>The endianness of each field. All fields that have more than one byte have endianness:    whether the bytes are ordered most-significant to least (big endian) or least-significant to most    (little endian). Okio uses the <code>Le</code> suffix for little-endian methods; methods without a suffix    are big-endian.</p> </li> <li> <p>Signed vs. Unsigned. Java doesn\u2019t have unsigned primitive types (except for <code>char</code>!) so    coping with this is often something that happens at the application layer. To make this a little    easier Okio accepts <code>int</code> types for <code>writeByte()</code> and <code>writeShort()</code>. You can pass an \u201cunsigned\u201d    byte like 255 and Okio will do the right thing.</p> </li> </ul> Method Width Endianness Value Encoded Value writeByte 1 3 <code>03</code> writeShort 2 big 3 <code>00 03</code> writeInt 4 big 3 <code>00 00 00 03</code> writeLong 8 big 3 <code>00 00 00 00 00 00 00 03</code> writeShortLe 2 little 3 <code>03 00</code> writeIntLe 4 little 3 <code>03 00 00 00</code> writeLongLe 8 little 3 <code>03 00 00 00 00 00 00 00</code> writeByte 1 Byte.MAX_VALUE <code>7f</code> writeShort 2 big Short.MAX_VALUE <code>7f ff</code> writeInt 4 big Int.MAX_VALUE <code>7f ff ff ff</code> writeLong 8 big Long.MAX_VALUE <code>7f ff ff ff ff ff ff ff</code> writeShortLe 2 little Short.MAX_VALUE <code>ff 7f</code> writeIntLe 4 little Int.MAX_VALUE <code>ff ff ff 7f</code> writeLongLe 8 little Long.MAX_VALUE <code>ff ff ff ff ff ff ff 7f</code> <p>This code encodes a bitmap following the BMP file format.</p> JavaKotlin <pre><code>void encode(Bitmap bitmap, BufferedSink sink) throws IOException {\n  int height = bitmap.height();\n  int width = bitmap.width();\n\n  int bytesPerPixel = 3;\n  int rowByteCountWithoutPadding = (bytesPerPixel * width);\n  int rowByteCount = ((rowByteCountWithoutPadding + 3) / 4) * 4;\n  int pixelDataSize = rowByteCount * height;\n  int bmpHeaderSize = 14;\n  int dibHeaderSize = 40;\n\n  // BMP Header\n  sink.writeUtf8(\"BM\"); // ID.\n  sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize); // File size.\n  sink.writeShortLe(0); // Unused.\n  sink.writeShortLe(0); // Unused.\n  sink.writeIntLe(bmpHeaderSize + dibHeaderSize); // Offset of pixel data.\n\n  // DIB Header\n  sink.writeIntLe(dibHeaderSize);\n  sink.writeIntLe(width);\n  sink.writeIntLe(height);\n  sink.writeShortLe(1);  // Color plane count.\n  sink.writeShortLe(bytesPerPixel * Byte.SIZE);\n  sink.writeIntLe(0);    // No compression.\n  sink.writeIntLe(16);   // Size of bitmap data including padding.\n  sink.writeIntLe(2835); // Horizontal print resolution in pixels/meter. (72 dpi).\n  sink.writeIntLe(2835); // Vertical print resolution in pixels/meter. (72 dpi).\n  sink.writeIntLe(0);    // Palette color count.\n  sink.writeIntLe(0);    // 0 important colors.\n\n  // Pixel data.\n  for (int y = height - 1; y &gt;= 0; y--) {\n    for (int x = 0; x &lt; width; x++) {\n      sink.writeByte(bitmap.blue(x, y));\n      sink.writeByte(bitmap.green(x, y));\n      sink.writeByte(bitmap.red(x, y));\n    }\n\n    // Padding for 4-byte alignment.\n    for (int p = rowByteCountWithoutPadding; p &lt; rowByteCount; p++) {\n      sink.writeByte(0);\n    }\n  }\n}\n</code></pre> <pre><code>@Throws(IOException::class)\nfun encode(bitmap: Bitmap, sink: BufferedSink) {\n  val height = bitmap.height\n  val width = bitmap.width\n  val bytesPerPixel = 3\n  val rowByteCountWithoutPadding = bytesPerPixel * width\n  val rowByteCount = (rowByteCountWithoutPadding + 3) / 4 * 4\n  val pixelDataSize = rowByteCount * height\n  val bmpHeaderSize = 14\n  val dibHeaderSize = 40\n\n  // BMP Header\n  sink.writeUtf8(\"BM\") // ID.\n  sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize) // File size.\n  sink.writeShortLe(0) // Unused.\n  sink.writeShortLe(0) // Unused.\n  sink.writeIntLe(bmpHeaderSize + dibHeaderSize) // Offset of pixel data.\n\n  // DIB Header\n  sink.writeIntLe(dibHeaderSize)\n  sink.writeIntLe(width)\n  sink.writeIntLe(height)\n  sink.writeShortLe(1) // Color plane count.\n  sink.writeShortLe(bytesPerPixel * Byte.SIZE_BITS)\n  sink.writeIntLe(0) // No compression.\n  sink.writeIntLe(16) // Size of bitmap data including padding.\n  sink.writeIntLe(2835) // Horizontal print resolution in pixels/meter. (72 dpi).\n  sink.writeIntLe(2835) // Vertical print resolution in pixels/meter. (72 dpi).\n  sink.writeIntLe(0) // Palette color count.\n  sink.writeIntLe(0) // 0 important colors.\n\n  // Pixel data.\n  for (y in height - 1 downTo 0) {\n    for (x in 0 until width) {\n      sink.writeByte(bitmap.blue(x, y))\n      sink.writeByte(bitmap.green(x, y))\n      sink.writeByte(bitmap.red(x, y))\n    }\n\n    // Padding for 4-byte alignment.\n    for (p in rowByteCountWithoutPadding until rowByteCount) {\n      sink.writeByte(0)\n    }\n  }\n}\n</code></pre> <p>The trickiest part of this program is the format\u2019s required padding. The BMP format expects each row to begin on a 4-byte boundary so it is necessary to add zeros to maintain the alignment.</p> <p>Encoding other binary formats is usually quite similar. Some tips:</p> <ul> <li>Write tests with golden values! Confirming that your program emits the expected result can make    debugging easier.</li> <li>Use <code>Utf8.size()</code> to compute the number of bytes of an encoded string. This is essential for    length-prefixed formats.</li> <li>Use <code>Float.floatToIntBits()</code> and <code>Double.doubleToLongBits()</code> to encode floating point values.</li> </ul>"},{"location":"recipes/#communicate-on-a-socket-javakotlin","title":"Communicate on a Socket (Java/Kotlin)","text":"<p>Note that Okio doesn\u2019t yet support sockets on Kotlin/Native or Kotlin/JS.</p> <p>Sending and receiving data over the network is a bit like writing and reading files. We use <code>BufferedSink</code> to encode output and <code>BufferedSource</code> to decode input. Like files, network protocols can be text, binary, or a mix of both. But there are also some substantial differences between the network and the file system.</p> <p>With a file you\u2019re either reading or writing but with the network you can do both! Some protocols handle this by taking turns: write a request, read a response, repeat. You can implement this kind of protocol with a single thread. In other protocols you may read and write simultaneously. Typically you\u2019ll want one dedicated thread for reading. For writing you can use either a dedicated thread or use <code>synchronized</code> so that multiple threads can share a sink. Okio\u2019s streams are not safe for concurrent use.</p> <p>Sinks buffer outbound data to minimize I/O operations. This is efficient but it means you must manually call <code>flush()</code> to transmit data. Typically message-oriented protocols flush after each message. Note that Okio will automatically flush when the buffered data exceeds some threshold. This is intended to save memory and you shouldn\u2019t rely on it for interactive protocols.</p> <p>Okio builds on <code>java.io.Socket</code> for connectivity. Create your socket as a server or as a client, then use <code>Okio.source(Socket)</code> to read and <code>Okio.sink(Socket)</code> to write. These APIs also work with <code>SSLSocket</code>. You should use SSL unless you have a very good reason not to!</p> <p>Cancel a socket from any thread by calling <code>Socket.close()</code>; this will cause its sources and sinks to immediately fail with an <code>IOException</code>. You can also configure timeouts for all socket operations. You don\u2019t need a reference to the socket to adjust timeouts: <code>Source</code> and <code>Sink</code> expose timeouts directly. This API works even if the streams are decorated.</p> <p>As a complete example of networking with Okio we wrote a basic SOCKS proxy server. Some highlights:</p> JavaKotlin <pre><code>Socket fromSocket = ...\nBufferedSource fromSource = Okio.buffer(Okio.source(fromSocket));\nBufferedSink fromSink = Okio.buffer(Okio.sink(fromSocket));\n</code></pre> <pre><code>val fromSocket: Socket = ...\nval fromSource = fromSocket.source().buffer()\nval fromSink = fromSocket.sink().buffer()\n</code></pre> <p>Creating sources and sinks for sockets is the same as creating them for files. Once you create a <code>Source</code> or <code>Sink</code> for a socket you must not use its <code>InputStream</code> or <code>OutputStream</code>, respectively.</p> JavaKotlin <pre><code>Buffer buffer = new Buffer();\nfor (long byteCount; (byteCount = source.read(buffer, 8192L)) != -1; ) {\n  sink.write(buffer, byteCount);\n  sink.flush();\n}\n</code></pre> <pre><code>val buffer = Buffer()\nvar byteCount: Long\nwhile (source.read(buffer, 8192L).also { byteCount = it } != -1L) {\n  sink.write(buffer, byteCount)\n  sink.flush()\n}\n</code></pre> <p>The above loop copies data from the source to the sink, flushing after each read. If we didn\u2019t need the flushing we could replace this loop with a single call to <code>BufferedSink.writeAll(Source)</code>.</p> <p>The <code>8192</code> argument to <code>read()</code> is the maximum number of bytes to read before returning. We could have passed any value here, but we like 8 KiB because that\u2019s the largest value Okio can do in a single system call. Most of the time application code doesn\u2019t need to deal with such limits!</p> JavaKotlin <pre><code>int addressType = fromSource.readByte() &amp; 0xff;\nint port = fromSource.readShort() &amp; 0xffff;\n</code></pre> <pre><code>val addressType = fromSource.readByte().toInt() and 0xff\nval port = fromSource.readShort().toInt() and 0xffff\n</code></pre> <p>Okio uses signed types like <code>byte</code> and <code>short</code>, but often protocols want unsigned values. The bitwise <code>&amp;</code> operator is Java\u2019s preferred idiom to convert a signed value into an unsigned value. Here\u2019s a cheat sheet for bytes, shorts, and ints:</p> Type Signed Range Unsigned Range Signed to Unsigned byte -128..127 0..255 <code>int u = s &amp; 0xff;</code> short -32,768..32,767 0..65,535 <code>int u = s &amp; 0xffff;</code> int -2,147,483,648..2,147,483,647 0..4,294,967,295 <code>long u = s &amp; 0xffffffffL;</code> <p>Java has no primitive type that can represent unsigned longs.</p>"},{"location":"recipes/#hashing-javakotlin","title":"Hashing (Java/Kotlin)","text":"<p>We\u2019re bombarded by hashing in our lives as Java programmers. Early on we\u2019re introduced to the <code>hashCode()</code> method, something we know we need to override otherwise unforeseen bad things happen. Later we\u2019re shown <code>LinkedHashMap</code> and its friends. These build on that <code>hashCode()</code> method to organize data for fast retrieval.</p> <p>Elsewhere we have cryptographic hash functions. These get used all over the place. HTTPS certificates, Git commits, BitTorrent integrity checking, and Blockchain blocks all use cryptographic hashes. Good use of hashes can improve the performance, privacy, security, and simplicity of an application.</p> <p>Each cryptographic hash function accepts a variable-length stream of input bytes and produces a fixed-length byte string value called the \u201chash\u201d. Hash functions have these important qualities:</p> <ul> <li>Deterministic: each input always produces the same output.</li> <li>Uniform: each output byte string is equally likely. It is very difficult to find or create pairs    of different inputs that yield the same output. This is called a \u201ccollision\u201d.</li> <li>Non-reversible: knowing an output doesn\u2019t help you to find the input. Note that if you know some    possible inputs you can hash them to see if their hashes match.</li> <li>Well-known: the hash is implemented everywhere and rigorously understood.</li> </ul> <p>Good hash functions are very cheap to compute (dozens of microseconds) and expensive to reverse (quintillions of millenia). Steady advances in computing and mathematics have caused once-great hash functions to become inexpensive to reverse. When choosing a hash function, beware that not all are created equal! Okio supports these well-known cryptographic hash functions:</p> <ul> <li>MD5: a 128-bit (16 byte) cryptographic hash. It is both insecure and obsolete because it is    inexpensive to reverse! This hash is offered because it is popular and convenient for use in    legacy systems that are not security-sensitive.</li> <li>SHA-1: a 160-bit (20 byte) cryptographic hash. It was recently demonstrated that it is    feasible to create SHA-1 collisions. Consider upgrading from SHA-1 to SHA-256.</li> <li>SHA-256: a 256-bit (32 byte) cryptographic hash. SHA-256 is widely understood and expensive    to reverse. This is the hash most systems should use.</li> <li>SHA-512: a 512-bit (64 byte) cryptographic hash. It is expensive to reverse.</li> </ul> <p>Each hash creates a <code>ByteString</code> of the specified length. Use <code>hex()</code> to get the conventional human-readable form. Or leave it as a <code>ByteString</code> because that\u2019s a convenient model type!</p> <p>Okio can produce cryptographic hashes from byte strings:</p> JavaKotlin <pre><code>ByteString byteString = readByteString(Path.get(\"README.md\"));\nSystem.out.println(\"   md5: \" + byteString.md5().hex());\nSystem.out.println(\"  sha1: \" + byteString.sha1().hex());\nSystem.out.println(\"sha256: \" + byteString.sha256().hex());\nSystem.out.println(\"sha512: \" + byteString.sha512().hex());\n</code></pre> <pre><code>val byteString = readByteString(\"README.md\".toPath())\nprintln(\"       md5: \" + byteString.md5().hex())\nprintln(\"      sha1: \" + byteString.sha1().hex())\nprintln(\"    sha256: \" + byteString.sha256().hex())\nprintln(\"    sha512: \" + byteString.sha512().hex())\n</code></pre> <p>From buffers:</p> JavaKotlin <pre><code>Buffer buffer = readBuffer(Path.get(\"README.md\"));\nSystem.out.println(\"   md5: \" + buffer.md5().hex());\nSystem.out.println(\"  sha1: \" + buffer.sha1().hex());\nSystem.out.println(\"sha256: \" + buffer.sha256().hex());\nSystem.out.println(\"sha512: \" + buffer.sha512().hex());\n</code></pre> <pre><code>val buffer = readBuffer(\"README.md\".toPath())\nprintln(\"       md5: \" + buffer.md5().hex())\nprintln(\"      sha1: \" + buffer.sha1().hex())\nprintln(\"    sha256: \" + buffer.sha256().hex())\nprintln(\"    sha512: \" + buffer.sha512().hex())\n</code></pre> <p>While streaming from a source:</p> JavaKotlin <pre><code>try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole());\n     BufferedSource source = Okio.buffer(FileSystem.SYSTEM.source(path))) {\n  source.readAll(hashingSink);\n  System.out.println(\"sha256: \" + hashingSink.hash().hex());\n}\n</code></pre> <pre><code>sha256(blackholeSink()).use { hashingSink -&gt;\n  FileSystem.SYSTEM.source(path).buffer().use { source -&gt;\n    source.readAll(hashingSink)\n    println(\"    sha256: \" + hashingSink.hash.hex())\n  }\n}\n</code></pre> <p>While streaming to a sink:</p> JavaKotlin <pre><code>try (HashingSink hashingSink = HashingSink.sha256(Okio.blackhole());\n     BufferedSink sink = Okio.buffer(hashingSink);\n     Source source = FileSystem.SYSTEM.source(path)) {\n  sink.writeAll(source);\n  sink.close(); // Emit anything buffered.\n  System.out.println(\"sha256: \" + hashingSink.hash().hex());\n}\n</code></pre> <pre><code>sha256(blackholeSink()).use { hashingSink -&gt;\n  hashingSink.buffer().use { sink -&gt;\n    FileSystem.SYSTEM.source(path).use { source -&gt;\n      sink.writeAll(source)\n      sink.close() // Emit anything buffered.\n      println(\"    sha256: \" + hashingSink.hash.hex())\n    }\n  }\n}\n</code></pre> <p>Okio also supports HMAC (Hash Message Authentication Code) which combines a secret and a hash. Applications use HMAC for data integrity and authentication.</p> JavaKotlin <pre><code>ByteString secret = ByteString.decodeHex(\"7065616e7574627574746572\");\nSystem.out.println(\"hmacSha256: \" + byteString.hmacSha256(secret).hex());\n</code></pre> <pre><code>val secret = \"7065616e7574627574746572\".decodeHex()\nprintln(\"hmacSha256: \" + byteString.hmacSha256(secret).hex())\n</code></pre> <p>As with hashing, you can generate an HMAC from a <code>ByteString</code>, <code>Buffer</code>, <code>HashingSource</code>, and <code>HashingSink</code>. Note that Okio doesn\u2019t implement HMAC for MD5.</p> <p>On Android and Java, Okio uses Java\u2019s <code>java.security.MessageDigest</code> for cryptographic hashes and <code>javax.crypto.Mac</code> for HMAC. On other platforms Okio uses its own optimized implementation of these algorithms.</p>"},{"location":"recipes/#encryption-and-decryption","title":"Encryption and Decryption","text":"<p>On Android and Java it\u2019s easy to encrypt streams.</p> <p>Callers are responsible for the initialization of the encryption or decryption cipher with the chosen algorithm, the key, and algorithm-specific additional parameters like the initialization vector. The following example shows a typical usage with AES encryption, in which <code>key</code> and <code>iv</code> parameters should both be 16 bytes long.</p> JavaKotlin <p>Use <code>Okio.cipherSink(Sink, Cipher)</code> or <code>Okio.cipherSource(Source, Cipher)</code> to encrypt or decrypt a stream using a block cipher.</p> <pre><code>void encryptAes(ByteString bytes, Path path, byte[] key, byte[] iv)\n    throws GeneralSecurityException, IOException {\n  Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n  try (BufferedSink sink = Okio.buffer(\n      Okio.cipherSink(FileSystem.SYSTEM.sink(path), cipher))) {\n    sink.write(bytes);\n  }\n}\n\nByteString decryptAesToByteString(Path path, byte[] key, byte[] iv)\n    throws GeneralSecurityException, IOException {\n  Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n  try (BufferedSource source = Okio.buffer(\n      Okio.cipherSource(FileSystem.SYSTEM.source(path), cipher))) {\n    return source.readByteString();\n  }\n}\n</code></pre> <p>Encryption and decryption functions are extensions on <code>Cipher</code>:</p> <pre><code>fun encryptAes(bytes: ByteString, path: Path, key: ByteArray, iv: ByteArray) {\n  val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n  cipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n  val cipherSink = FileSystem.SYSTEM.sink(path).cipherSink(cipher)\n  cipherSink.buffer().use {\n    it.write(bytes)\n  }\n}\n\nfun decryptAesToByteString(path: Path, key: ByteArray, iv: ByteArray): ByteString {\n  val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n  cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n  val cipherSource = FileSystem.SYSTEM.source(path).cipherSource(cipher)\n  return cipherSource.buffer().use {\n    it.readByteString()\n  }\n}\n</code></pre>"},{"location":"releasing/","title":"Releasing","text":"<ol> <li> <p>Update <code>CHANGELOG.md</code>.</p> </li> <li> <p>Set versions:</p> <pre><code>export RELEASE_VERSION=X.Y.Z\nexport NEXT_VERSION=X.Y.Z-SNAPSHOT\n</code></pre> </li> <li> <p>Update versions, tag the release, and prepare for the next release.</p> <pre><code>sed -i \"\" \\\n  \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\\n  gradle.properties\nsed -i \"\" \\\n  \"s/\\\"com.squareup.okio:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okio:\\1:$RELEASE_VERSION\\\"/g\" \\\n  `find . -name \"index.md\"`\n\ngit commit -am \"Prepare for release $RELEASE_VERSION.\"\ngit tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\"\n\nsed -i \"\" \\\n  \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\\n  gradle.properties\ngit commit -am \"Prepare next development version.\"\n\ngit push &amp;&amp; git push --tags\n</code></pre> </li> <li> <p>Wait for GitHub Actions to build and promote the release.</p> </li> </ol>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#supported-versions","title":"Supported Versions","text":"Version Supported 3.x \u2705 2.x \u2705 1.x \u2705"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository.</p> <p>If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource</p>"}]}